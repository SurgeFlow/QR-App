<!--
  How to run
  - macOS/Linux:  python3 -m http.server
  - Windows (PowerShell):  python -m http.server
  - Node.js:  npx http-server
  Then open http://localhost:8000 and click the view to lock pointer.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tiny First‑Person World • Three.js (WebGL2)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root {
      color-scheme: dark;
      --hud-bg: rgba(0,0,0,0.35);
      --hud-text: #e8f0ff;
      --accent: #7fd1ff;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #0a0f1a;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas#c {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      outline: none;
    }
    /* HUD */
    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 8px 10px;
      background: var(--hud-bg);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      color: var(--hud-text);
      user-select: none;
      backdrop-filter: blur(6px);
      font-weight: 600;
      letter-spacing: 0.2px;
      font-size: 14px;
      z-index: 2;
    }
    #hud .row { display: flex; align-items: baseline; gap: 10px; }
    #hud .value { color: #fff; font-variant-numeric: tabular-nums; }
    /* FPS meter */
    #perf {
      position: fixed;
      top: 12px;
      right: 12px;
      min-width: 120px;
      padding: 8px 10px;
      background: var(--hud-bg);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 8px;
      color: var(--hud-text);
      font-size: 12px;
      line-height: 1.15;
      font-variant-numeric: tabular-nums;
      user-select: none;
      backdrop-filter: blur(6px);
      z-index: 2;
    }
    #perf .bar {
      position: relative;
      height: 6px;
      border-radius: 4px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
      margin-top: 6px;
    }
    #perf .bar > span {
      position: absolute;
      inset: 0 0 0 auto;
      width: 0%;
      background: linear-gradient(90deg, #55ffa3, #7fd1ff);
      filter: saturate(1.1);
    }
    /* Overlay (instructions) */
    #overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 600px at 50% 40%, rgba(20,40,70,0.45), rgba(10,15,26,0.9));
      color: #dfe9ff;
      text-align: center;
      z-index: 3;
      opacity: 0;
      animation: fadeIn 800ms ease forwards 200ms;
      transition: opacity 220ms ease;
      backdrop-filter: blur(2px);
      padding: 24px;
    }
    #overlay.hidden { opacity: 0; pointer-events: none; }
    @keyframes fadeIn { to { opacity: 1; } }
    .panel {
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 20px 22px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.06);
      max-width: 520px;
    }
    .panel h1 {
      margin: 0 0 6px 0;
      font-size: 20px;
      letter-spacing: 0.4px;
      color: #fff;
    }
    .panel p {
      margin: 6px 0;
      opacity: 0.9;
      font-size: 14px;
    }
    .panel kbd {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-bottom-color: rgba(0,0,0,0.35);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 12px;
      color: #fff;
      display: inline-block;
      box-shadow: 0 2px 0 rgba(0,0,0,0.2);
    }
    .panel button {
      margin-top: 12px;
      padding: 10px 14px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(180deg, #77b9ff, #3b89ff);
      color: white;
      font-weight: 700;
      letter-spacing: 0.3px;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(34,90,200,0.5);
    }
    /* Fallback message */
    #fallback {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: #0b0f18;
      color: #e5efff;
      text-align: center;
      padding: 24px;
      z-index: 999;
    }
    #fallback .panel { max-width: 680px; }
    a { color: var(--accent); text-decoration: none; }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.1);
      font-size: 11px;
      margin-left: 8px;
      vertical-align: 1px;
      color: #cfe1ff;
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="c"></canvas>
    <div id="hud" aria-live="polite">
      <div class="row">Collectibles <span class="pill">touch to pick</span> <span id="collected" class="value">0</span>/<span id="total" class="value">0</span></div>
    </div>
    <div id="perf">
      <div><strong id="fps">0.0</strong> fps • <span id="ms">0.0</span> ms</div>
      <div class="bar" aria-hidden="true"><span id="fpsbar"></span></div>
    </div>
    <div id="overlay">
      <div class="panel">
        <h1>Click to lock pointer</h1>
        <p>Move with <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>, look with mouse, <kbd>Space</kbd> jump, hold <kbd>Shift</kbd> to sprint.</p>
        <button id="start">Enter World</button>
        <p style="opacity:.75;margin-top:8px">This is a tiny first‑person 3D world running in WebGL2 + Three.js.</p>
      </div>
    </div>
    <div id="fallback" style="display:none">
      <div class="panel">
        <h1>WebGL2 not available</h1>
        <p>Your browser or GPU doesn’t seem to support WebGL2. Try a modern Chromium, Firefox, or Safari, and ensure hardware acceleration is enabled.</p>
        <p style="opacity:.8">Tip: <a href="https://get.webgl.org/" target="_blank" rel="noopener">test WebGL</a></p>
      </div>
    </div>
  </div>

  <script type="module">
    // Minimal WebGL2 availability check (show graceful fallback)
    const webgl2OK = (() => {
      const gl = document.createElement('canvas').getContext('webgl2', { powerPreference: 'high-performance' });
      return !!gl;
    })();
    if (!webgl2OK) {
      document.getElementById('fallback').style.display = 'grid';
      throw new Error('WebGL2 not supported.');
    }

    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/PointerLockControls.js';

    // --- Globals (kept lean) ---
    let renderer, scene, camera, controls, clock;
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start');
    const hudCollected = document.getElementById('collected');
    const hudTotal = document.getElementById('total');
    const fpsEl = document.getElementById('fps');
    const msEl = document.getElementById('ms');
    const fpsBar = document.getElementById('fpsbar');

    // Player capsule (approx) and movement state
    const player = {
      position: new THREE.Vector3(0, 0, 0),           // base anchor at ground plane when standing
      velocity: new THREE.Vector3(),
      onFloor: false,
      wantsJump: false,
      collider: { start: new THREE.Vector3(0, 0.35, 0), end: new THREE.Vector3(0, 1.55, 0), radius: 0.35 },
      speed: { walk: 4.5, sprint: 8.0, jump: 6.5 }
    };
    const tmpV1 = new THREE.Vector3(), tmpV2 = new THREE.Vector3(), tmpV3 = new THREE.Vector3();
    const GRAVITY = 22.0;
    const DT_CLAMP = 1 / 30; // clamp spikes (s)

    // World geometry references for collisions/raycast
    const colliders = [];     // meshes of props for raycast
    const colliderBoxes = []; // AABBs for simple capsule-vs-box resolution
    let groundMesh;

    // Collectibles
    const orbs = [];
    let collected = 0;

    // Input
    const keys = { w:false, a:false, s:false, d:false, shift:false, space:false };

    // --- Boot ---
    initScene();
    initLights();
    spawnGroundAndSky();
    spawnProps();
    initControls();
    clock = new THREE.Clock();

    // HUD totals
    hudTotal.textContent = '0';

    // Resize now + on changes
    handleResize();
    window.addEventListener('resize', handleResize);

    // Start on user gesture
    startBtn.addEventListener('click', () => controls.lock());
    document.body.addEventListener('click', () => { if (!controls.isLocked) controls.lock(); });

    // Pointer lock overlay
    controls.addEventListener('lock', () => overlay.classList.add('hidden'));
    controls.addEventListener('unlock', () => overlay.classList.remove('hidden'));

    // Main loop
    renderer.setAnimationLoop(render);

    // --- Init functions ---
    function initScene() {
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x0a1022, 0.018); // soft fog

      camera = new THREE.PerspectiveCamera(80, 1, 0.1, 500);
      camera.position.set(0, 1.65, 5);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, powerPreference: 'high-performance' });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
    }

    function initLights() {
      const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x223344, 0.7);
      hemi.position.set(0, 1, 0);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(12, 20, -8);
      dir.castShadow = true;
      dir.shadow.mapSize.set(2048, 2048);
      dir.shadow.camera.near = 0.5;
      dir.shadow.camera.far = 100;
      dir.shadow.camera.left = -40;
      dir.shadow.camera.right = 40;
      dir.shadow.camera.top = 40;
      dir.shadow.camera.bottom = -40;
      dir.shadow.radius = 2.5; // softer
      scene.add(dir);
    }

    function spawnGroundAndSky() {
      // Procedural checker ground (CanvasTexture)
      const gridTex = makeCheckerTexture(128, 128, 8, '#2b3347', '#29324a', 0.65);
      gridTex.wrapS = gridTex.wrapT = THREE.RepeatWrapping;
      gridTex.repeat.set(80, 80);
      gridTex.anisotropy = 4;

      const groundMat = new THREE.MeshStandardMaterial({ map: gridTex, roughness: 0.95, metalness: 0.0 });
      const groundGeo = new THREE.PlaneGeometry(500, 500);
      groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.receiveShadow = true;
      groundMesh.name = 'ground';
      scene.add(groundMesh);
      colliders.push(groundMesh);

      // Gradient sky dome (simple shader)
      const skyGeo = new THREE.SphereGeometry(220, 32, 18);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          topColor:   { value: new THREE.Color(0x0d2a5a) },
          bottomColor:{ value: new THREE.Color(0x0a0f1a) },
          offset:     { value: 0.0 },
          exponent:   { value: 1.2 }
        },
        vertexShader: `
          varying vec3 vWorldPos;
          void main() {
            vec4 wp = modelMatrix * vec4(position, 1.0);
            vWorldPos = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          varying vec3 vWorldPos;
          uniform vec3 topColor;
          uniform vec3 bottomColor;
          uniform float offset;
          uniform float exponent;
          void main() {
            float h = normalize(vWorldPos).y * 0.5 + 0.5;
            h = pow(max(h + offset, 0.0), exponent);
            vec3 col = mix(bottomColor, topColor, h);
            gl_FragColor = vec4(col, 1.0);
          }
        `
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);
    }

    function initControls() {
      controls = new PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      controls.getObject().position.copy(player.position).add(new THREE.Vector3(0, 1.6, 5)); // starting a bit away

      // Input
      window.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'KeyW': keys.w = true; break;
          case 'KeyA': keys.a = true; break;
          case 'KeyS': keys.s = true; break;
          case 'KeyD': keys.d = true; break;
          case 'ShiftLeft':
          case 'ShiftRight': keys.shift = true; break;
          case 'Space': keys.space = true; player.wantsJump = true; break;
        }
      });
      window.addEventListener('keyup', (e) => {
        switch (e.code) {
          case 'KeyW': keys.w = false; break;
          case 'KeyA': keys.a = false; break;
          case 'KeyS': keys.s = false; break;
          case 'KeyD': keys.d = false; break;
          case 'ShiftLeft':
          case 'ShiftRight': keys.shift = false; break;
          case 'Space': keys.space = false; break;
        }
      });
    }

    function spawnProps() {
      // Variety of simple props with different procedural looks
      const group = new THREE.Group();
      scene.add(group);

      const rng = mulberry32(1337);
      const palette = [0x9ad1ff, 0xffe08a, 0xc8ffd4, 0xf2b3ff, 0xffb0b0].map(c => new THREE.Color(c));

      // Scatter boxes and columns
      for (let i = 0; i < 26; i++) {
        const isColumn = (i % 3) === 0;
        const size = isColumn ? [1.2, 3 + rng()*3, 1.2] : [1+ rng()*2, 1+ rng()*1.5, 1 + rng()*2];
        const geo = isColumn ? new THREE.CylinderGeometry(size[0]*0.5, size[0]*0.5, size[1], 16)
                             : new THREE.BoxGeometry(size[0], size[1], size[2]);
        const col = palette[i % palette.length].clone().offsetHSL(rng()*0.1, 0, (rng()-0.5)*0.1);
        const mat = new THREE.MeshStandardMaterial({
          color: col, roughness: 0.6 + rng()*0.35, metalness: 0.05 + rng()*0.1
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Position in a rough ring, avoid spawn origin
        const r = 16 + rng()*60;
        const a = rng()*Math.PI*2;
        mesh.position.set(Math.cos(a)*r, size[1]*0.5, Math.sin(a)*r);
        if (!isColumn) {
          mesh.rotation.y = rng()*Math.PI;
        }
        group.add(mesh);

        // Track for collisions
        const box = new THREE.Box3().setFromObject(mesh);
        colliderBoxes.push({ box, mesh }); // keep mesh for raycast/updates
        colliders.push(mesh);
      }

      // Collectibles (orbs)
      const orbGeo = new THREE.IcosahedronGeometry(0.25, 1);
      for (let i = 0; i < 12; i++) {
        const m = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL((i/12), 0.6, 0.55),
          emissive: new THREE.Color().setHSL((i/12), 0.7, 0.3),
          roughness: 0.3, metalness: 0.0
        });
        const orb = new THREE.Mesh(orbGeo, m);
        orb.castShadow = true;
        orb.userData = { baseY: 0, t: rng()*Math.PI*2, collected: false, pulse: 0 };

        // Orbit around a random prop or spot
        const r = 10 + rng()*55;
        const a = rng()*Math.PI*2;
        orb.position.set(Math.cos(a)*r, 1.2 + rng()*1.0, Math.sin(a)*r);

        scene.add(orb);
        orbs.push(orb);
      }
      hudTotal.textContent = String(orbs.length);
    }

    // --- Render & update ---
    const raycaster = new THREE.Raycaster();
    raycaster.far = 3.0;

    // Simple perf meter
    const perf = { last: performance.now(), fps: 0, ms: 0 };
    function updatePerf() {
      const now = performance.now();
      const ms = now - perf.last;
      perf.last = now;
      perf.ms = ms * 0.9 + perf.ms * 0.1;
      const fps = 1000 / ms;
      perf.fps = fps * 0.1 + perf.fps * 0.9;

      fpsEl.textContent = (perf.fps).toFixed(1);
      msEl.textContent = (perf.ms).toFixed(1);
      const pct = Math.max(0, Math.min(100, (perf.fps / 120) * 100));
      fpsBar.style.width = pct + '%';
    }

    function render() {
      updatePerf();

      const rawDt = clock.getDelta();
      const dt = Math.min(rawDt, DT_CLAMP); // clamp spikes

      updatePhysics(dt);
      updateOrbs(dt);

      renderer.render(scene, camera);
    }

    function updatePhysics(dt) {
      // Camera holder is the FPS "body"
      const obj = controls.getObject();

      // Movement input (camera-relative, horizontal only)
      tmpV1.set(0,0,-1).applyQuaternion(camera.quaternion); tmpV1.y = 0; tmpV1.normalize(); // forward
      tmpV2.set(1,0,0).applyQuaternion(camera.quaternion);  tmpV2.y = 0; tmpV2.normalize(); // right

      const wish = tmpV3.set(0,0,0);
      if (keys.w) wish.add(tmpV1);
      if (keys.s) wish.sub(tmpV1);
      if (keys.d) wish.add(tmpV2);
      if (keys.a) wish.sub(tmpV2);
      if (wish.lengthSq() > 0) wish.normalize();

      const onFloor = player.onFloor;
      const accel = onFloor ? 42 : 12;
      const maxSpeed = (keys.shift ? player.speed.sprint : player.speed.walk);
      // Horizontal velocity approach target (critically damped-ish)
      const desired = wish.multiplyScalar(maxSpeed);
      player.velocity.x += (desired.x - player.velocity.x) * Math.min(1, accel * dt);
      player.velocity.z += (desired.z - player.velocity.z) * Math.min(1, accel * dt);

      // Gravity & jump
      if (onFloor) {
        player.velocity.y = Math.max(0, player.velocity.y); // no sinking
        if (player.wantsJump) {
          player.velocity.y = player.speed.jump;
          player.wantsJump = false;
          player.onFloor = false;
        }
      } else {
        player.velocity.y -= GRAVITY * dt;
      }

      // Integrate
      player.position.addScaledVector(player.velocity, dt);

      // Floor clamp (plane at y=0)
      if (player.position.y < 0) {
        player.position.y = 0;
      }

      // Capsule vs props (simple resolution using three sample spheres along capsule)
      player.onFloor = false;
      const startY = player.position.y + player.collider.start.y;
      const endY   = player.position.y + player.collider.end.y;
      const radius = player.collider.radius;

      // Iterate to resolve interpenetrations robustly
      for (let iter = 0; iter < 3; iter++) {
        for (let i = 0; i < colliderBoxes.length; i++) {
          const { box } = colliderBoxes[i];
          // three sphere samples to approximate capsule
          if (resolveSphereBox(startY, box, radius)) continue;
          if (resolveSphereBox((startY+endY)*0.5, box, radius)) continue;
          resolveSphereBox(endY, box, radius);
        }
      }

      // Ground contact via downward ray to catch tiny gaps/edges
      tmpV1.copy(player.position).add(player.collider.start);
      raycaster.set(tmpV1.add({x:0, y:0.2, z:0}), new THREE.Vector3(0,-1,0));
      const hits = raycaster.intersectObjects(colliders, false);
      if (hits.length && (hits[0].distance <= 0.25)) {
        player.onFloor = true;
        // Small positional nudge to "sit" on top
        player.position.y += (0.25 - hits[0].distance);
      }

      // Write position back to camera rig (eye roughly near capsule top)
      obj.position.copy(player.position).y += 1.62;

      // --- helpers ---
      function resolveSphereBox(centerY, box, r) {
        // Sphere center at (player.position.x, centerY, player.position.z)
        tmpV1.set(player.position.x, centerY, player.position.z);
        // Closest point on AABB
        const cx = Math.max(box.min.x, Math.min(tmpV1.x, box.max.x));
        const cy = Math.max(box.min.y, Math.min(tmpV1.y, box.max.y));
        const cz = Math.max(box.min.z, Math.min(tmpV1.z, box.max.z));
        tmpV2.set(cx, cy, cz);

        // Vector from box to sphere center
        tmpV3.subVectors(tmpV1, tmpV2);
        const distSq = tmpV3.lengthSq();
        if (distSq >= r*r) return false;

        let dist = Math.sqrt(Math.max(1e-12, distSq));
        // If center is fully inside the box, push out along smallest face
        if (dist < 1e-6) {
          const dx = Math.min(Math.abs(tmpV1.x - box.min.x), Math.abs(box.max.x - tmpV1.x));
          const dy = Math.min(Math.abs(tmpV1.y - box.min.y), Math.abs(box.max.y - tmpV1.y));
          const dz = Math.min(Math.abs(tmpV1.z - box.min.z), Math.abs(box.max.z - tmpV1.z));
          tmpV3.set(0,0,0);
          if (dx <= dy && dx <= dz) tmpV3.set(Math.sign(tmpV1.x - (box.min.x + box.max.x)*0.5), 0, 0);
          else if (dz <= dy)        tmpV3.set(0, 0, Math.sign(tmpV1.z - (box.min.z + box.max.z)*0.5));
          else                      tmpV3.set(0, Math.sign(tmpV1.y - (box.min.y + box.max.y)*0.5), 0);
          dist = 1.0;
        } else {
          tmpV3.multiplyScalar(1.0 / dist); // normal
        }

        const penetration = r - dist;
        // Move entire capsule by normal * penetration
        player.position.addScaledVector(tmpV3, penetration);

        // Slide: remove inward velocity along the normal
        const vn = player.velocity.dot(tmpV3);
        if (vn < 0) player.velocity.addScaledVector(tmpV3, -vn);

        // Floor detection
        if (tmpV3.y > 0.65) player.onFloor = true;

        return true;
      }
    }

    function updateOrbs(dt) {
      for (let i = 0; i < orbs.length; i++) {
        const orb = orbs[i];
        if (orb.userData.collected) {
          // Pulse then hide
          orb.userData.pulse -= dt * 4.0;
          const s = Math.max(0, 1 + orb.userData.pulse * 0.6);
          orb.scale.setScalar(s);
          if (orb.userData.pulse <= 0) {
            orb.visible = false;
          }
          continue;
        }

        // Float & spin
        orb.userData.t += dt;
        const bob = Math.sin(orb.userData.t * 2.0) * 0.12;
        orb.position.y += bob * dt * 6.0;
        orb.rotation.y += dt * 1.2;

        // Collect on touch with capsule (use middle sphere)
        const r = player.collider.radius + 0.4;
        tmpV1.copy(orb.position);
        tmpV2.set(player.position.x, (player.position.y + (player.collider.start.y + player.collider.end.y)*0.5), player.position.z);
        if (tmpV1.distanceToSquared(tmpV2) < r*r) {
          orb.userData.collected = true;
          orb.userData.pulse = 1.0;
          collected++;
          hudCollected.textContent = String(collected);
        }
      }
    }

    // --- Utilities ---
    function handleResize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
      // Cap internal render size to avoid extreme DPI cost
      const maxW = 1920, maxH = 1080;
      const w = Math.min(window.innerWidth, maxW);
      const h = Math.min(window.innerHeight, maxH);
      renderer.setPixelRatio(dpr);
      renderer.setSize(w, h, false);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }

    function makeCheckerTexture(w, h, cells, c0, c1, alpha=1) {
      const cnv = document.createElement('canvas');
      cnv.width = w; cnv.height = h;
      const ctx = cnv.getContext('2d');
      const s = w / cells;
      for (let y = 0; y < cells; y++) {
        for (let x = 0; x < cells; x++) {
          ctx.fillStyle = ((x + y) % 2 === 0) ? c0 : c1;
          ctx.globalAlpha = alpha;
          ctx.fillRect(x*s, y*s, s, s);
        }
      }
      // Subtle diagonal noise overlay
      ctx.globalAlpha = 0.08;
      for (let y = 0; y < h; y+=4) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, y, w, 1);
      }
      const tex = new THREE.CanvasTexture(cnv);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    // Keep AABBs updated if objects move (not needed here but robust for future)
    function refreshColliderBoxes() {
      for (let i = 0; i < colliderBoxes.length; i++) {
        colliderBoxes[i].box.setFromObject(colliderBoxes[i].mesh);
      }
    }

    // Safety: avoid accidental GC churn
    renderer.info.autoReset = true;
  </script>
</body>
</html>
